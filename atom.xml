<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Arse_nan</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gunner4life.com/"/>
  <updated>2016-08-31T12:42:34.000Z</updated>
  <id>http://gunner4life.com/</id>
  
  <author>
    <name>Arse_nan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android事件分发机制</title>
    <link href="http://gunner4life.com//blog/2016/08/31/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>http://gunner4life.com//blog/2016/08/31/Android事件分发机制/</id>
    <published>2016-08-31T12:42:09.000Z</published>
    <updated>2016-08-31T12:42:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分发流程概述"><a href="#分发流程概述" class="headerlink" title="分发流程概述"></a>分发流程概述</h2><p>所有Touch事件都被封装成MotionEvent对象，包括Touch的位置、时间、历史记录等等。事件最先传递给当前的Activity，由Activity的dispatchTouchEvent来进行事件的分发<br><img src="http://dn-arsenan.qbox.me/14726430496180.jpg" alt=""><br>事件开始交给Activity所附属的Window来进行分发，Window是个抽象类，具体的实现在PhoneWindow当中<br><img src="http://dn-arsenan.qbox.me/14726432484932.jpg" alt=""><br>其中mDecor为DecorView，即根View<br><img src="http://dn-arsenan.qbox.me/14726431452301.jpg" alt=""><br>即事件传递到了ViewGroup的dispatchTouchEvent中，然后继续传递给子元素(默认情况)<br>总的来说，当一个点击事件产生后，它的传递过程遵循如下顺序：Activity -&gt; Window -&gt; View，即事件总是先传递给Activity，Activity再传递给Window，最后Window再传递给顶级的View(DecorView)，顶级View接收到事件后，就会按照事件分发机制去分发事件。如果一个View的onTouchEvent返回false(没有消耗事件)，那么它父容器的onTouchEvent将会被调用，依次类推，如果所有的元素都不去处理这个事件，那么这个事件最终将会传递给Activity处理，即Activity的onTouchEvent方法会被调用</p>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul>
<li>如果ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件(ViewGroup的onInterceptTouchEvent默认返回false，即默认不拦截任何事件)，接着这个ViewGroup的onTouchEvent就会被调用，如果onInterceptTouchEvent返回false，那么就会继续向下调用子元素的dispatchTouchEvent方法</li>
<li>当一个View需要处理事件的时候，如果它没有设置onTouchListener，那么就会直接调用onTouchEvent，如果设置了onTouchListener，那么就要看Listener的onTouch方法返回值，为false，则当前View的onTouchEvent方法会被调用，如果为true，则onTouchEvent将不会被调用。</li>
<li>给View设置onTouchListener，其优先级比onTouchEvent要高，在onTouchEvent方法中，如果设置了onClickListener，那么它的onClick方法会被调用。可以看出，onClickListener的优先级最低</li>
<li>某个View一旦拦截了某个事件，那么这一个事件序列里面后续的Move、Down等事件都会交由它处理，并且它的onTnterceptTouchEvent不会再调用</li>
<li>某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件，那么同一时间序列中的其他事件都不会再交给它来处理，并且事件将重新交给它的父元素处理，即父元素的onTouchEvent会被调用</li>
<li>View的onTouchEvent默认都会消耗事件(返回true)，除非它是不可点击的(clickable和longClickable同时为false)，但是enable属性不会影响onTouchEvent返回值</li>
<li>事件传递过程是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的时间分发，但是ACTION_DOWN事件除外，它不受此影响</li>
</ul>
<ol>
<li><p>View不处理事件流程图<br><img src="http://dn-arsenan.qbox.me/ignorant-view-example.jpg" alt="ignorant-view-example"></p>
</li>
<li><p>View处理事件流程图<br><img src="http://dn-arsenan.qbox.me/interested-view-example.jpg" alt="interested-view-example"></p>
</li>
<li><p>ViewGroup拦截事件处理流程图<br><img src="http://dn-arsenan.qbox.me/14726463384715.jpg" alt=""></p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://a.codekk.com/detail/Android/Trinea/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20View%20%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92" target="_blank" rel="external">公共技术点之View事件传递</a></li>
<li><a href="http://trinea.github.io/download/pdf/android/PRE_andevcon_mastering-the-android-touch-system.pdf" target="_blank" rel="external">Mastering the Android Touch System</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分发流程概述&quot;&gt;&lt;a href=&quot;#分发流程概述&quot; class=&quot;headerlink&quot; title=&quot;分发流程概述&quot;&gt;&lt;/a&gt;分发流程概述&lt;/h2&gt;&lt;p&gt;所有Touch事件都被封装成MotionEvent对象，包括Touch的位置、时间、历史记录等等。事件最先传
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android消息机制</title>
    <link href="http://gunner4life.com//blog/2016/08/31/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>http://gunner4life.com//blog/2016/08/31/Android消息机制/</id>
    <published>2016-08-31T08:22:38.000Z</published>
    <updated>2016-08-31T09:07:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android的消息机制主要是指Handler的运行机制. 而Handler的运行需要底层的MessageQueue和Looper做支撑</p>
<ul>
<li>MessageQueue内部存储了一组消息，以队列的形式对外提供入列和出列的操作，采用的是单链表的数据结构来存储消息队列</li>
<li>Looper会以无限循环的形式去查找MessageQueue中是否有新的消息，如有就处理消息，否则就一直等待着</li>
</ul>
<h2 id="Handler的创建"><a href="#Handler的创建" class="headerlink" title="Handler的创建"></a>Handler的创建</h2><p>首先看一下Handler的构造函数<br><img src="http://dn-arsenan.qbox.me/14726229847414.jpg" alt=""><br>可以看到会通过调用Looper.myLooper()方法来获取一个Looper对象，如果Looper对象为空，则会抛出一个运行时异常，继续看myLooper方法<br><img src="http://dn-arsenan.qbox.me/14726231666612.jpg" alt=""><br>这个方法非常简单，就是从sThreadLocal对象中取出Looper，那么由此而来的一个问题便是在哪里给sThreadLocal设置了Looper，通过阅读代码可知，设置的地方位于prepare方法当中<br><img src="http://dn-arsenan.qbox.me/14726233498932.jpg" alt=""><br>总结一下，就是必须先调用Looper.prepare()方法来创建一个Looper对象，否则无法创建Handler对象<br>But…<br>为什么我们在主线程中不需要通过调用prepare方法也能创建Handler呢？<br>这是由于在程序启动时，系统已经帮我们自动调用了Looper.prepareMainLooper()方法，当App的进程创建好之后，会去执行ActivityThread中的main()方法，main方法的代码如下<br><img src="http://dn-arsenan.qbox.me/14726240426790.jpg" alt=""><br>而prepareMainLooper方法中又会去调用prepare方法<br><img src="http://dn-arsenan.qbox.me/14726241118057.jpg" alt=""><br>因此我们应用程序的主线程种始终存在一个Looper对象，因而不需要再通过调用Looper.prepare来再进行创建，可以直接在主线程中直接创建Handler对象</p>
<h2 id="发送Message"><a href="#发送Message" class="headerlink" title="发送Message"></a>发送Message</h2><p>通常我们先实例化一个Message对象，然后通过Handler的sendMessage方法来发送这条消息，那么这条消息是如何被发送出去的呢？<br>首先看一下sendMessage方法<br><img src="http://dn-arsenan.qbox.me/14726255951577.jpg" alt=""><br>会调用sendMessageDelayed方法，delayMillis为0，表示的是消息不做延时发送<br><img src="http://dn-arsenan.qbox.me/14726256231796.jpg" alt=""><br>然后会继续调用sendMessageAtTime方法，传入发送的时间<br><img src="http://dn-arsenan.qbox.me/14726257474287.jpg" alt=""><br>这里可以看到在继续处理之前会先获取MessageQueue实例，这个就是我们前面提到的消息存储的队列，这个队列是在Handler创建时从Looper中获取的(详见上面Handler构造函数)，而Looper中的mQueue是在Looper创建时new出来的<br>总结起来就是Looper.prepare时会调用Looper的构造函数，创建一个MessageQueue对象，然后Handler在实例化的时候会将当前Looper的MessageQueue赋值给Handler<br>继续上面发送消息的流程，可以看到获取到这个MessageQueue对象之后，会调用enqueueMessage方法<br><img src="http://dn-arsenan.qbox.me/14726264714931.jpg" alt=""><br>首先会设置Message中的target为当前的Handler，然后继续调用MessageQueue的enqueueMessage方法<br><img src="http://dn-arsenan.qbox.me/14726267478155.jpg" alt=""><br>通过代码可以知道这是通过单链表的方式来存储消息，消息的入队其实就是将所有的消息按时间来进行排序，通过以上流程就完成了一个Message的入队操作(通过MessageQueue存储)</p>
<h2 id="Looper获取消息"><a href="#Looper获取消息" class="headerlink" title="Looper获取消息"></a>Looper获取消息</h2><p>前面分析了一个Message从创建到最终如何存储到MessageQueue的过程，接下来我们看看MessageQueue中消息的出队流程。MessageQueue的出队是依靠Looper中的loop方法来实现的<br><img src="http://dn-arsenan.qbox.me/14726277745914.jpg" alt=""><br><img src="http://dn-arsenan.qbox.me/14726291564401.jpg" alt=""></p>
<p>可以看到loop方法是一个死循环，唯一跳出循环的方式是MessageQueue的next方法返回了null。而next方法是一个阻塞操作，当没有消息时，next方法会一直阻塞在那里，这也导致loop方法一直阻塞在那里(新消息来了后会继续处理，处理完后继续阻塞)。只有当Looper的quit方法被调用时，Looper会调用MessageQueue的quit或者quitSafely方法来通知消息队列退出，当消息队列被标为退出状态时，它的next方法就会返回null，此时loop方法才会跳出死循环<br>总结一下就是，loop方法会不断的调用MessageQueue的next方法来获取队列中的消息，没有消息时，也不会退出循环，当有新消息来的时候又能够及时的去处理消息，只有通过调用quit方法才能让Looper退出循环</p>
<h2 id="处理消息"><a href="#处理消息" class="headerlink" title="处理消息"></a>处理消息</h2><p>继续上面的分析可知，loop中取出的消息是通过调用msg.target.dispatchMessage来处理的，这个msg.target就是对应的Handler对象(详见上面Handler的sendMessage方法)，即消息最终是交由Handler的dispatchMessage来处理的，而dispatchMessage是在创建Handler时所使用的Looper中执行的，这样就成功的将代码逻辑切换到指定的线程中去执行了<br><img src="http://dn-arsenan.qbox.me/14726305495162.jpg" alt=""><br>dispatchMessage方法的实现如上，当没有callback时(Handler sendMessage方法就是没有callback)，最终会执行handleMessage方法，这样就收到了之前发送的消息</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>整个消息处理流程示意图如下<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-31%20%E4%B8%8B%E5%8D%885.04.11.png" alt="屏幕快照 2016-08-31 下午5.04.11"></p>
<p>另外除了发送消息之外，还有几种方法能在子线程中进行UI操作:</p>
<ul>
<li>Handler的post方法</li>
<li>View的post方法</li>
<li>Activity的runOnUiThread方法</li>
</ul>
<p>具体的实现跟上面的流程没什么区别，唯一的区别是消息的不是在handleMessage中处理，而是通过callback方式处理(参见上面的dispatchMessage)</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/9991569" target="_blank" rel="external">Android异步消息处理机制完全解析，带你从源码的角度彻底理解</a></li>
<li><a href="https://www.zhihu.com/question/34652589" target="_blank" rel="external">Android中为什么主线程不会因为Looper.loop()里的死循环卡死</a></li>
<li><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="external">Android消息机制1-Handler(Java层)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android的消息机制主要是指Handler的运行机制. 而Handler的运行需要底层的MessageQueue和Looper做支撑&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MessageQueue内部存储了一组消息，以队列的形式对外提供入列和出列的操作，采用的是单链表的数据结构来存
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android系统启动流程</title>
    <link href="http://gunner4life.com//blog/2016/08/31/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://gunner4life.com//blog/2016/08/31/Android系统启动流程/</id>
    <published>2016-08-31T01:53:22.000Z</published>
    <updated>2016-08-31T01:55:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-30%20%E4%B8%8B%E5%8D%883.15.05.png" alt="屏幕快照 2016-08-30 下午3.15.05"></p>
<ul>
<li>Linux Kernel加载完成后，会运行init.rc脚本</li>
<li>init进程执行app_process，创建Zygote进程，然后通过AppRuntime这个对象启动ZygoteInit类</li>
<li>运行ZygoteInit的main方法，首先会通过registerZygoteSocket方法创建一个供AMS使用的server socket</li>
<li>通过调用startSystemServer，会调用Zygote.forkSystemServer来fork出SystemServer进程</li>
<li>SystemServer进程启动后会执行<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-30%20%E4%B8%8B%E5%8D%883.30.48.png" alt="屏幕快照 2016-08-30 下午3.30.48"><br>从而将ActivityManagerService、WindowManagerService、PackageManagerService等系统核心服务启动起来</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-30%20%E4%B8%8B%E5%8D%883.15.05.png&quot; alt=&quot;屏幕快照 2016-08-
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Activity启动过程分析</title>
    <link href="http://gunner4life.com//blog/2016/08/31/Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://gunner4life.com//blog/2016/08/31/Activity启动过程分析/</id>
    <published>2016-08-31T01:51:56.000Z</published>
    <updated>2016-08-31T01:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="APP首次启动"><a href="#APP首次启动" class="headerlink" title="APP首次启动"></a>APP首次启动</h2><p><img src="http://dn-arsenan.qbox.me/start_activity_process.jpg" alt="start_activity_process"></p>
<ol>
<li>Launcher进程通过Binder向SystemServer进程发起startActivity请求</li>
<li>SystemServer收到请求后，向Zygote进程发起创建进程的请求</li>
<li>Zygote进程fork出新的子进程，即App进程，然后执行ActivityThread的main方法</li>
<li>App进程通过Binder向SystemServer进程发起attachApplication请求<br>App首次启动较正常的Activity启动多出了2、3、4三个步骤，其余的完整启动过程请参见下面的「调用流程」</li>
</ol>
<h2 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h2><p><strong>1. 调用Activity的startActivity方法</strong><br><img src="http://dn-arsenan.qbox.me/14725443309497.jpg" alt=""><br>最终会走到startActivityForResult中，当Activity没有父Activity时，会调用Instrumentation的execStartActivity</p>
<hr>
<p><strong>2. 调用Instrumentation的execStartActivity</strong><br><img src="http://dn-arsenan.qbox.me/14725442182212.jpg" alt=""><br>最终调用的是ActivityManagerNative.getDefault().startActivity</p>
<hr>
<p><strong>3. 调用ActivityManagerNative.getDefault()的startActivity</strong><br><img src="http://dn-arsenan.qbox.me/14725447896006.jpg" alt=""><br><img src="http://dn-arsenan.qbox.me/14725447592646.jpg" alt=""><br>由以上可知ActivityManagerNative.getDefault().startActivity实际上调用的是ActivityManagerProxy(ActivityManagerProxy为ActivityManagerNative的内部类)的startActivity方法，具体实现如下:<br><img src="http://dn-arsenan.qbox.me/14725450883257.jpg" alt=""><br>其中mRemote是一个IBinder对象，由ActivityManagerProxy的构造函数中传入，对应的就是asInterface方法中的obj对象，继续追踪可知，这个obj对象指向的是远程的ActivityManagerService，通过调用mRemote.transact(START_ACTIVITY_TRANSACTION)会通过Binder进程间通信机制，发起START_ACTIVITY_TRANSACTION事务，并将Intent等信息序列化后传给远程服务ActivityManagerService</p>
<hr>
<p><strong>4. 执行ActivityManagerService的startActivity方法</strong><br>ActivityManagerService的startActivity会调用ActivityStackSupervisor的startActivityMayWait，后续又会执行一些其它的调用操作，流程如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startActivityMayWait -&gt; startActivityLocked -&gt; startActivityUncheckedLocked -&gt; startSpecificActivityLocked -&gt; realStartActivityLocked</div></pre></td></tr></table></figure></p>
<p>realStartActivityLocked方法最终的执行如下<br><img src="http://dn-arsenan.qbox.me/14725469143399.jpg" alt=""><br>最终会执行ApplicationThreadProxy的scheduleLaunchActivity方法</p>
<hr>
<p><strong>5. 执行ApplicationThreadProxy的scheduleLaunchActivity方法</strong><br><img src="http://dn-arsenan.qbox.me/14725473289431.jpg" alt=""><br>这里又会通过Binder向远程服务发送一个SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION事务，远端的服务收到之后最终会调用ApplicationThread(ActivityThread的内部类)的scheduleLaunchActivity方法</p>
<hr>
<p><strong>6. 执行ApplicationThread的scheduleLaunchActivity方法</strong><br><img src="http://dn-arsenan.qbox.me/14725477248697.jpg" alt=""><br>调用sendMessage方法，Handler收到消息后会调用handleLaunchActivity方法，里面会依次执行handleConfigurationChanged、performLaunchActivity、handleResumeActivity等方法<br>其中performLaunchActivity方法会先通过反射构造Activity实例，然后调用Activity的attach方法，设置Theme、最后会由Instrumentation调用callActivityOnCreate等方法<br><img src="http://dn-arsenan.qbox.me/14725485607501.jpg" alt=""><br><img src="http://dn-arsenan.qbox.me/14725485923974.jpg" alt=""></p>
<hr>
<p><strong>7. 执行Instrumentation的callActivityOnCreate</strong><br><img src="http://dn-arsenan.qbox.me/14725486990498.jpg" alt=""><br>接着会调用Activity的performCreate方法</p>
<hr>
<p><strong>8. Activity的performCreate方法</strong><br><img src="http://dn-arsenan.qbox.me/14725487574177.jpg" alt=""><br>最终会调用Activity的onCreate方法</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://mouxuejie.com/blog/2016-03-12/activity-launch-analysis/" target="_blank" rel="external">［Android四大组件］Activity启动过程源码分析</a></li>
<li><a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="external">startActivity流程分析(一)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;APP首次启动&quot;&gt;&lt;a href=&quot;#APP首次启动&quot; class=&quot;headerlink&quot; title=&quot;APP首次启动&quot;&gt;&lt;/a&gt;APP首次启动&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://dn-arsenan.qbox.me/start_activity
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Studio创建Google MVP模板</title>
    <link href="http://gunner4life.com//blog/2016/08/30/Android-Studio%E5%88%9B%E5%BB%BAGoogle-MVP%E6%A8%A1%E6%9D%BF/"/>
    <id>http://gunner4life.com//blog/2016/08/30/Android-Studio创建Google-MVP模板/</id>
    <published>2016-08-30T02:46:59.000Z</published>
    <updated>2016-08-30T03:01:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android-Studio模板"><a href="#Android-Studio模板" class="headerlink" title="Android Studio模板"></a>Android Studio模板</h2><p>Android Studio模板能帮助用户快速的在Android Studio种创建文件及生成基础的模板代码，例如可以通过File -&gt; New -&gt; Activity -&gt; Basic Activity来新建一个Basic Activity模板，Android Studio把自动帮我们生成一个Activity及Activity对应的布局文件，这个Basic Activity模板就是Android Studio众多的模板之一</p>
<p>Android Studio工程模板的路径位于/Applications/Android Studio.app/Contents/plugins/android/lib/templates</p>
<p>一个典型的Android Studio模板包含以下内容<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%883.56.39.png" alt="屏幕快照 2016-08-29 下午3.56.39"></p>
<ul>
<li><strong>globals.xml.ftl</strong> 定义了一些全局的变量</li>
<li><strong>recipe.xml.ftl</strong> 定义从模板文件生成代码时需要执行的操作，例如可以cope、merge文件</li>
<li><strong>root/</strong> 包含模板文件的文件夹</li>
<li><strong>template.xml</strong> 定义新建模板面板上所显示的内容(类、布局的名称等)、引用的globals文件、执行的recipe文件等</li>
</ul>
<h2 id="Google-MVP"><a href="#Google-MVP" class="headerlink" title="Google MVP"></a>Google MVP</h2><p>Google MVP模式中包含有:</p>
<ul>
<li><strong>Contract</strong> 定义View接口及Presenter接口的契约类</li>
<li><strong>Fragment</strong> 实现Contract中的View接口，用于UI相关的处理</li>
<li><strong>Presenter</strong> 实现Contract种的Presenter接口，用于业务逻辑相关的处理</li>
<li><strong>Activity</strong> 用于生成Fragment Presenter </li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>template.xml</strong><br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%886.37.28.png" alt="屏幕快照 2016-08-29 下午6.37.28"><br>新建模板面板上显示了包括Activity、Activity Layout、Contract、Presenter、Fragment、Fragment Layout的名称，所有的名称都会随着Activity输入进行动态变化，大部分情况只需要定义好Activity的名称即可</p>
<hr>
<p><strong>recipe.xml.ftl</strong><br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%886.41.41.png" alt="屏幕快照 2016-08-29 下午6.41.41"><br>自动将生成的Activity注册到Manifest文件中，同时会生成MVP的各个文件，最后打开Activity文件</p>
<hr>
<p>MVPContract.java.ftl<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%886.42.21.png" alt="屏幕快照 2016-08-29 下午6.42.21"><br>定义View及Presenter接口</p>
<hr>
<p>MVPFragment.java.ftl<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%886.42.58.png" alt="屏幕快照 2016-08-29 下午6.42.58"></p>
<ol>
<li>绑定Presenter，同时在onResume种调用start方法</li>
<li>提供实例化Fragment的方法</li>
<li>绑定对应的布局文件</li>
</ol>
<hr>
<p>MVPPresenter.java.ftl<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%886.43.42.png" alt="屏幕快照 2016-08-29 下午6.43.42"><br>将View与Presenter互相绑定</p>
<hr>
<p>MVPActivity.java.ftl<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%886.44.19.png" alt="屏幕快照 2016-08-29 下午6.44.19"><br>实例化Fragment、Presenter，同时将Fragment(View)作为参数传入Presenter中</p>
<hr>
<p>AndroidManifest.xml.ftl<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%886.44.59.png" alt="屏幕快照 2016-08-29 下午6.44.59"><br>注册新生成的Activity</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%887.22.32.png" alt="屏幕快照 2016-08-29 下午7.22.32"><br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%887.23.35.png" alt="屏幕快照 2016-08-29 下午7.23.35"><br>之后会生成对应的六个文件<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%887.24.45.png" alt="屏幕快照 2016-08-29 下午7.24.45"><br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%887.24.10.png" alt="屏幕快照 2016-08-29 下午7.24.10"><br>打开的DemoActivity显示如下<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%887.24.29.png" alt="屏幕快照 2016-08-29 下午7.24.29"><br>同时DemoActivity也已自动注册到AndroidManifest文件种了<br>至此，就生成了一个完成MVP框架需要的所有文件</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>完整代码请参考 <a href="https://github.com/gunner4life/GoogleMVPTemplate" target="_blank" rel="external">Github</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://robusttechhouse.com/tutorial-how-to-create-custom-android-code-templates/" target="_blank" rel="external">Tutorial How To Create Custom Android Code Templates</a></li>
<li><a href="http://www.i-programmer.info/professional-programmer/resources-and-tools/6845-android-adt-template-format-document.html" target="_blank" rel="external">Android ADT Template Format Document</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Android-Studio模板&quot;&gt;&lt;a href=&quot;#Android-Studio模板&quot; class=&quot;headerlink&quot; title=&quot;Android Studio模板&quot;&gt;&lt;/a&gt;Android Studio模板&lt;/h2&gt;&lt;p&gt;Android Studio
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://gunner4life.com//blog/2016/07/21/hello-world/"/>
    <id>http://gunner4life.com//blog/2016/07/21/hello-world/</id>
    <published>2016-07-21T12:21:37.000Z</published>
    <updated>2016-07-21T12:21:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
