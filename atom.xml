<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Arse_nan</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gunner4life.com/"/>
  <updated>2016-09-10T09:13:10.000Z</updated>
  <id>http://gunner4life.com/</id>
  
  <author>
    <name>Arse_nan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android ClassLoader工作机制</title>
    <link href="http://gunner4life.com//blog/2016/09/10/Android-ClassLoader%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
    <id>http://gunner4life.com//blog/2016/09/10/Android-ClassLoader工作机制/</id>
    <published>2016-09-10T09:12:43.000Z</published>
    <updated>2016-09-10T09:13:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>ClassLoader是专门用来处理类加载工作的，所以也称为类加载器，并且一个运行的App中不仅只有一个类加载器:<br>在Android系统启动的时候会创建一个Boot类型的ClassLoader实例(BootClassLoader)，用于加载一些系统Framework层级需要的类，我们的Android应用里也需要用到一些系统的类，所以App启动的时候也会把这个Boot类型的ClassLoader传进来。此外，App也有自己的类，这些类保存在APK的dex文件里面，所以App启动的时候，也会创建一个自己的ClassLoader实例(PathClassLoader)，用于加载自己dex文件中的类</p>
<h2 id="创建自己的ClassLoader实例"><a href="#创建自己的ClassLoader实例" class="headerlink" title="创建自己的ClassLoader实例"></a>创建自己的ClassLoader实例</h2><p>首先先看一下它的构造方法<br><img src="http://dn-arsenan.qbox.me/14734004305111.jpg" alt=""><br>可以看到，创建一个ClassLoader实例的时候，需要使用一个现有的ClassLoader实例作为新创建的实例的Parent. 这样一来，一个Android应用，甚至整个Android系统里所有的ClassLoader实例都会被一棵树关联起来，这也是ClassLoader的<strong>双亲代理模型</strong>的特点</p>
<h2 id="ClassLoader双亲代理模型加载类的特点和作用"><a href="#ClassLoader双亲代理模型加载类的特点和作用" class="headerlink" title="ClassLoader双亲代理模型加载类的特点和作用"></a>ClassLoader双亲代理模型加载类的特点和作用</h2><p>JVM中ClassLoader通过defineClass方法加载jar里面的Class, 而Android中这个方法是被弃用了<br><img src="http://dn-arsenan.qbox.me/14734009948288.jpg" alt=""><br>取而代之的是loadClass方法<br><img src="http://dn-arsenan.qbox.me/14734013273864.jpg" alt=""></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>从上面的源码中可以看出，loadClass方法在加载一个类的实例的时候:</p>
<ol>
<li>会先查询当前ClassLoader实例是否加载过此类，有就返回</li>
<li>如果没有，查询Parent是否已经加载过此类，如果已经加载过，就直接返回Parent加载的类</li>
<li>如果继承线路上的ClassLoader都没有加载，才有Child执行类的加载工作</li>
</ol>
<p>这样做有个明显的特点，如果一个类被位于树根的ClassLoader加载过，那么在以后整个系统的生命周期内，这个类永远不会被重新加载</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><p>共享功能<br>一些Framework层级的类一旦被顶层的ClassLoader加载过就缓存在内存里面，以后任何地方用到就都不需要重新加载</p>
</li>
<li><p>隔离功能<br>不同继承线路上的ClassLoader加载的类肯定不是同一个类，这样的限制避免了用户自己的代码冒充核心类库的类访问核心类库包可见成员的情况，比如String, 如果在一个应用里面能够简单的用自定义的String类把这个系统的String类给替换掉，那将会有严重的安全问题</p>
</li>
</ul>
<h2 id="使用ClassLoader的注意事项"><a href="#使用ClassLoader的注意事项" class="headerlink" title="使用ClassLoader的注意事项"></a>使用ClassLoader的注意事项</h2><ul>
<li><p>如果希望通过动态加载的方式，加载一个新版本的dex文件，使用里面的新类替换原有的旧类，从而修复原有类的bug，那么必须保证在加载新类的时候，旧类还没有被加载，因为如果已经加载过旧类，那么ClassLoader会一直优先使用旧类</p>
</li>
<li><p>如果旧类总是优先于新类被加载，我们也可以使用一个与加载旧类的ClassLoader没有树继承关系的另一个ClassLoader来加载新类，因为ClassLoader只会检查其Parent有没有加载过当前要加载的类，如果两个ClassLoader没有继承关系，那么旧类和新类都能被加载</p>
</li>
<li><p>在Java中，只有两个实例的类名、包名以及加载其的ClassLoader都相同，才会被认为是同一种类型，即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">同一个Class = 相同的ClassName + PackageName + ClassLoader</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="类加载器初始化及加载过程"><a href="#类加载器初始化及加载过程" class="headerlink" title="类加载器初始化及加载过程"></a>类加载器初始化及加载过程</h2><p>在Android中，ClassLoader是一个抽象类，实际开发过程中，我们一般使用其具体的子类如: DexClassLoader、PathClassLoader来加载类，它们的不同支出是: </p>
<ul>
<li>DexClassLoader可以加载jar/apk/dex，可以从SD卡中加载未安装的apk</li>
<li>PathClassLoader只能加载系统中已经安装过的apk</li>
</ul>
<h3 id="类加载器初始化"><a href="#类加载器初始化" class="headerlink" title="类加载器初始化"></a>类加载器初始化</h3><p>两者的构造方法如下:<br><img src="http://dn-arsenan.qbox.me/14734033909388.jpg" alt=""><br>两者只是简单的对BaseDexClassLoader做了一下封装，具体的实现还是在父类里，不同的是PathClassLoader的optimizedDirectory传的是null<br>而在BaseDexClassLoader中<br><img src="http://dn-arsenan.qbox.me/14734036410378.jpg" alt=""><br>这里创建了一个DexPathList实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">public DexPathList(ClassLoader definingContext, String dexPath,</div><div class="line">        String libraryPath, File optimizedDirectory) &#123;</div><div class="line">    ……</div><div class="line">    this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static Element[] makeDexElements(ArrayList&lt;File&gt; files,</div><div class="line">        File optimizedDirectory) &#123;</div><div class="line">    ArrayList&lt;Element&gt; elements = new ArrayList&lt;Element&gt;();</div><div class="line">    for (File file : files) &#123;</div><div class="line">        ZipFile zip = null;</div><div class="line">        DexFile dex = null;</div><div class="line">        String name = file.getName();</div><div class="line">        if (name.endsWith(DEX_SUFFIX)) &#123;</div><div class="line">            dex = loadDexFile(file, optimizedDirectory);</div><div class="line">        &#125; else if (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX)</div><div class="line">                || name.endsWith(ZIP_SUFFIX)) &#123;</div><div class="line">            zip = new ZipFile(file);</div><div class="line">        &#125;</div><div class="line">        ……</div><div class="line">        if ((zip != null) || (dex != null)) &#123;</div><div class="line">            elements.add(new Element(file, zip, dex));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return elements.toArray(new Element[elements.size()]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static DexFile loadDexFile(File file, File optimizedDirectory)</div><div class="line">        throws IOException &#123;</div><div class="line">    if (optimizedDirectory == null) &#123;</div><div class="line">        return new DexFile(file);</div><div class="line">    &#125; else &#123;</div><div class="line">        String optimizedPath = optimizedPathFor(file, optimizedDirectory);</div><div class="line">        return DexFile.loadDex(file.getPath(), optimizedPath, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Converts a dex/jar file path and an output directory to an</div><div class="line"> * output file path for an associated optimized dex file.</div><div class="line"> */</div><div class="line">private static String optimizedPathFor(File path,</div><div class="line">        File optimizedDirectory) &#123;</div><div class="line">    String fileName = path.getName();</div><div class="line">    if (!fileName.endsWith(DEX_SUFFIX)) &#123;</div><div class="line">        int lastDot = fileName.lastIndexOf(&quot;.&quot;);</div><div class="line">        if (lastDot &lt; 0) &#123;</div><div class="line">            fileName += DEX_SUFFIX;</div><div class="line">        &#125; else &#123;</div><div class="line">            StringBuilder sb = new StringBuilder(lastDot + 4);</div><div class="line">            sb.append(fileName, 0, lastDot);</div><div class="line">            sb.append(DEX_SUFFIX);</div><div class="line">            fileName = sb.toString();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    File result = new File(optimizedDirectory, fileName);</div><div class="line">    return result.getPath();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，optimizedDirectory是用来缓存我们需要加载的dex文件的，并创建一个DexFile对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile对象<br>optimizedDirectory必须是一个<strong>内部存储路径</strong>(<strong>无论哪种动态加载，加载的可执行文件一定要存放在内部存储</strong>). DexClassLoader可以加载外部的dex，因为这个dex会被复制到DexClassLoader指定的内部路径(optimizedDirectory)，然后供DexClassLoader加载. 而PathClassLoader没有optimizedDirectory，所以它只能加载内部的dex，这些大都是存在系统中已经安装过的apk里</p>
<h3 id="加载类的过程"><a href="#加载类的过程" class="headerlink" title="加载类的过程"></a>加载类的过程</h3><p>上面说过当某个类第一次被加载时，会调用findClass方法，而BaseDexClassLoader重载了这个方法，如下:<br><img src="http://dn-arsenan.qbox.me/14734179814754.jpg" alt=""><br>调用了DexPathList的findClass方法<br><img src="http://dn-arsenan.qbox.me/14734180508605.jpg" alt=""><br>这里遍历了之前所有的DexFile实例，其实也就是遍历了所有加载过的dex文件，再调用loadClassBinaryName方法一个个尝试能不能加载想要的类，而loadClassBinaryName中调用了Native方法definaClass来加载类<br>这样就完成了一个类的加载工作</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://segmentfault.com/a/1190000004062880" target="_blank" rel="external">Android动态加载基础 ClassLoader工作机制</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ClassLoader是专门用来处理类加载工作的，所以也称为类加载器，并且一个运行的App中不仅只有一个类加载器:&lt;br&gt;在Android系统启动的时候会创建一个Boot类型的ClassLoader实例(BootClassLoader)，用于加载一些系统Framework层
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android内存泄露总结</title>
    <link href="http://gunner4life.com//blog/2016/09/09/Android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%80%BB%E7%BB%93/"/>
    <id>http://gunner4life.com//blog/2016/09/09/Android内存泄露总结/</id>
    <published>2016-09-09T02:04:16.000Z</published>
    <updated>2016-09-09T02:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中的内存泄露"><a href="#Java中的内存泄露" class="headerlink" title="Java中的内存泄露"></a>Java中的内存泄露</h2><h3 id="什么是内存泄露"><a href="#什么是内存泄露" class="headerlink" title="什么是内存泄露"></a>什么是内存泄露</h3><p>内存泄露是指无用对象(不再使用的对象)持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄露</p>
<p>在Java中，内存泄露就是存在一些被分配的对象，这些对象有下面两个特点:</p>
<ul>
<li>这些对象是可达的，即在有向图中，存在通路可以与其相连</li>
<li>这些对象是无用的，即程序以后不会再使用这些对象</li>
</ul>
<p>这些对象不会被GC所回收，然而它却占用内存，这些对象就可以判定为Java中的内存泄露</p>
<h3 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h3><p>Java中内存泄露的根本原因在于: <strong>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露</strong>，尽管短生命周期的对象已经不需要了，但是因为长生命周期的对象持有它的引用而导致不能被回收</p>
<h2 id="Android中常见的内存泄露"><a href="#Android中常见的内存泄露" class="headerlink" title="Android中常见的内存泄露"></a>Android中常见的内存泄露</h2><h3 id="集合类泄露"><a href="#集合类泄露" class="headerlink" title="集合类泄露"></a>集合类泄露</h3><p>集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用，如果这个集合类是全局性的变量，那么如果没有相应的删除机制，很可能导致集合所占用的内存只增不减，因为添加的对象始终无法被释放掉，导致内存泄露</p>
<h3 id="单例造成的内存泄露"><a href="#单例造成的内存泄露" class="headerlink" title="单例造成的内存泄露"></a>单例造成的内存泄露</h3><p>由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄露，例如:<br><img src="http://dn-arsenan.qbox.me/14731550008716.jpg" alt=""><br>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要:</p>
<ul>
<li>如果此时传入的是Application的Context，因为Application的生命周期就是整个应用的生命周期，所以这将没有什么问题</li>
<li>如果此时传入的是Activity的Context，那么当这个Context所对应的Activity退出时，由于该Context的引用被单例对象所持有，所以它的内存并不会被回收，这就造成了内存泄露</li>
</ul>
<p>正确的方式应该是:<br><img src="http://dn-arsenan.qbox.me/14731553340735.jpg" alt=""><br>或者是，连Context都不用传进来<br><img src="http://dn-arsenan.qbox.me/14731554430399.jpg" alt=""></p>
<h3 id="匿名内部类、非静态内部类"><a href="#匿名内部类、非静态内部类" class="headerlink" title="匿名内部类、非静态内部类"></a>匿名内部类、非静态内部类</h3><p>非静态内部类默认会持有外部类的引用(所以在它里面可以直接访问外部的变量、常量)，如果此时又创建了这个非静态内部类的实例，则该实例的生命周期和应用一样长，这就导致了外部类所占用的内存资源不能正常回收，从而引起内存泄露<br>匿名内部类也是同理</p>
<h3 id="Handler造成的内存泄露"><a href="#Handler造成的内存泄露" class="headerlink" title="Handler造成的内存泄露"></a>Handler造成的内存泄露</h3><p>由于Handler属于TLS(Thread Local Storage)变量，生命周期和Activity是不一致的，因此一般很难保证跟View或者Activity的生命周期保持一致，故很容易导致无法正确释放，一般的解决方式是: 在Activity中避免使用非静态内部类，将Handler声明为静态的，同时通过弱引用的方式引入Activity，避免直接将Activity作为Context传进去，这样在回收时也可以回收Handler持有的对象，避免了Activity泄露<br>上面提到了弱引用(WeakReference)，所以这里就简单的说一下Java对象的几种引用类型<br>Java对引用的分类有Strong reference, SoftReference, WeakReference, PhatomReference四种<br><img src="http://dn-arsenan.qbox.me/14733315405998.jpg" alt=""><br>继续回到主题，虽然这样避免了Activity泄露，不过Looper线程的消息队列中还是可能会有待处理的消息，所以我们在Activity的Destroy时或者Stop时应该移除消息队列MessageQueue中的消息，移除的方法有:<br><img src="http://dn-arsenan.qbox.me/14733318362376.jpg" alt=""></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>尽量避免使用static成员变量</li>
<li>避免override finalize()</li>
<li>避免资源未关闭造成的内存泄露</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>对Activity等组件的引用应该控制在Activity的生命周期之内；如果不能就考虑用getApplicationContext或者getApplication，以避免Activity被外部长生命周期的对象引用而泄露</li>
<li>尽量不要在静态变量或者静态内部类中使用非静态外部成员变量(包括context)，即使要使用，也要考虑适时把外部成员变量置空；也可以在内部类中使用弱引用来引用外部类的变量</li>
<li><p>对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做以避免内存泄露:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1. 将内部类改为静态内部类</div><div class="line">2. 静态内部类中使用弱引用来引用外部类的成员变量</div></pre></td></tr></table></figure>
</li>
<li><p>Handler持有的引用对象最好使用弱引用，资源释放时也可以清空Handler里面的消息. 比如在Activity onStop或者onDestroy的时候，取消该Handler对象的Message和Runnable</p>
</li>
<li>在Java的实现过程中，也要考虑其对象的释放，最好的方法是在不使用某对象时，显式的将此对象赋值为null，比如使用完Bitmap后先调用recycler()，再赋为null</li>
<li>正确关闭资源，对于使用了BroadcastReceiver、ContentObserver、File、Cursor、Steam、Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销</li>
<li>保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/GeniusVJR/LearningNotes/blob/master/Part1/Android/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93.md" target="_blank" rel="external">Android 内存泄露总结</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java中的内存泄露&quot;&gt;&lt;a href=&quot;#Java中的内存泄露&quot; class=&quot;headerlink&quot; title=&quot;Java中的内存泄露&quot;&gt;&lt;/a&gt;Java中的内存泄露&lt;/h2&gt;&lt;h3 id=&quot;什么是内存泄露&quot;&gt;&lt;a href=&quot;#什么是内存泄露&quot; class
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM内存管理</title>
    <link href="http://gunner4life.com//blog/2016/09/09/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://gunner4life.com//blog/2016/09/09/JVM内存管理/</id>
    <published>2016-09-09T02:02:54.000Z</published>
    <updated>2016-09-09T02:03:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM内存分配策略"><a href="#JVM内存分配策略" class="headerlink" title="JVM内存分配策略"></a>JVM内存分配策略</h2><p>Java程序运行时的内存分配策略有三种，分别是静态分配、栈式分配和堆式分配，所使用的内存空间依次对应为静态存储区(方法区)、栈区和堆区</p>
<ul>
<li><p>静态存储区(方法区)<br>主要存放静态数据、全局static数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在</p>
</li>
<li><p>栈区<br>当方法被执行时，方法体内的局部变量(包括基础数据类型、对象的引用)都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。由于栈内存分配计算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</p>
</li>
<li><p>堆区<br>又称动态内存分配，通常就是指在程序运行时直接new出来的内存，也就是对象的实例，这部分内存在不使用时将会由Java垃圾回收器来负责回收<br>在Java中，堆被划分为两个不同的区域：新生代(Young)、老年代(Old). 其中新生代又被划分为三个区域: Eden、From Survivor、To Survivor<br>堆的内存模型大致为:<br><img src="http://dn-arsenan.qbox.me/14730647330766.jpg" alt=""><br>其中JVM每次只会使用Eden和其中一块Survivor区域来为对象服务，所以无论什么时候，总是有一块Survivor区域是空闲的. 因此，新生代实际可用的内存空间为9/10(即90%)的新生代空间</p>
</li>
</ul>
<h2 id="GC堆"><a href="#GC堆" class="headerlink" title="GC堆"></a>GC堆</h2><p>Java中的堆是GC收集垃圾的主要区域。GC分为两种: Minor GC、Major GC、Full GC</p>
<ul>
<li><p>Minor GC<br>Minor GC是发生在新生代中的垃圾收集动作，所采用的是复制算法<br>新生代几乎是所有Java对象出生的地方，也是GC垃圾收集的频繁区域. 当对象在Eden(包括一个Survivor区域，这里假设是from区域)出生后，在经过一次Minor GC后，如果对象还存活，并且能够被另一块Survivor区域所容纳，则使用复制算法将这些仍存活的对象复制到另一块Survivor区域(前面假设诞生在from区域，则这里是to区域)中，然后清理所使用过的Eden以及Survivor区域，并且将这些对象的年龄设置为1，以后对象在Survivor区每熬过一次Minor GC，就将对象的年龄+1，当对象年龄达到某个值时(默认15)，这些对象就会成为老年代。但这也不是绝对的，对于一些较大的对象则直接进入到老年代</p>
</li>
<li><p>Major GC<br>Major GC是发生在老年代的垃圾收集动作，所采用的是标记-清除算法<br>Major GC发生的次数不会有Major GC那么频繁，并且做一次Major GC要比进行一次Minor GC的时间更长. 另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片(即不连续的内存空间)，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次GC</p>
</li>
<li><p>Full GC<br>Full GC是清理整个堆(包括新生代和老年代空间)</p>
</li>
</ul>
<h2 id="GC回收原理"><a href="#GC回收原理" class="headerlink" title="GC回收原理"></a>GC回收原理</h2><p>垃圾回收器从GC Roots的点开始遍历对象，凡是可以达到的点(存在引用关系)都会标记为存活，堆中不可到达的对象都会标记成垃圾，然后被清理掉<br>Java使用有向图的方式进行内存管理，可以消除引用循环的问题，例如有三个对象，相互引用，只要它们和根进程不可达，那么GC也是可以回收他们的</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://blog.csdn.net/gyqjn/article/details/49848473" target="_blank" rel="external">Java GC、新生代、老年代</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JVM内存分配策略&quot;&gt;&lt;a href=&quot;#JVM内存分配策略&quot; class=&quot;headerlink&quot; title=&quot;JVM内存分配策略&quot;&gt;&lt;/a&gt;JVM内存分配策略&lt;/h2&gt;&lt;p&gt;Java程序运行时的内存分配策略有三种，分别是静态分配、栈式分配和堆式分配，所使用的
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android View绘制机制</title>
    <link href="http://gunner4life.com//blog/2016/09/02/Android-View%E7%BB%98%E5%88%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://gunner4life.com//blog/2016/09/02/Android-View绘制机制/</id>
    <published>2016-09-02T09:06:30.000Z</published>
    <updated>2016-09-02T09:06:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="绘制流程概览"><a href="#绘制流程概览" class="headerlink" title="绘制流程概览"></a>绘制流程概览</h2><p>整个View树的绘制流程是从ViewRootImpl的performTraversals开始的，依次会调用performMeasure、performLayout和performDraw三个方法，这三个方法分别完成顶级View的measure、layout、draw这三大流程</p>
<p>其中performMeasure中会调用measure方法，在measure中又会调用onMeasure方法，在onMeasure中则会对所有的子元素进行measure过程，这个时候measure流程就从父容器传递到子元素肿了，这样就完成了一次measure过程。接着子元素会重复父容器的measure过程，如此反复就完成整个View树的遍历。同理，performLayout和performDraw的传递流程和performMeasure是类似的，唯一不同的是，performDraw的传递过程是在draw中通过dispatchDraw来实现的，流程图如下:</p>
<p><img src="http://dn-arsenan.qbox.me/14727874986587.png" alt=""></p>
<h2 id="measure"><a href="#measure" class="headerlink" title="measure"></a>measure</h2><p><img src="http://dn-arsenan.qbox.me/14728009325435.png" alt=""></p>
<p>measure过程决定了View的宽高，它会为View及所有子节点的mMeasuredWidth和mMeasuredHeight变量赋值，Measure完成以后，可以通过getMeasuredWidth和getMeasuredHeight来获取到View测量后的宽高，而且这两个值必须在父视图约束范围之内，这样才能保证所有的父视图都接收所有子视图的测量。如果子视图对于Measure得到的大小不满意的时候，父视图会介入并设置测量规则进行第二次measure</p>
<h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><p>MeasureSpec代表一个32位int值，分别记录了尺寸(SpecSize)和计算尺寸的测量模式(SpecMode)，其中SpecMode有三种值:</p>
<ul>
<li><strong>UNSPECIFIED</strong>  一般是系统使用(如ListView、ScrollView，一般自定义View中用不到)，父容器不对View做限制，要多大给多大</li>
<li><strong>EXACTLY</strong>  父容器已经检测出View所需要的精准大小，对应具体的数值或LayoutParams的<code>match_parent</code></li>
<li><strong>AT_MOST</strong>  对应LayoutParams的<code>wrap_content</code>，父容器指定了一个SpecSize的大小，View的大小不能大于这个值，具体是什么值要看不同View的具体实现</li>
</ul>
<p>在调用子元素measure方法之前会先通过getChildMeasureSpec方法来得到子元素的MeasureSpec，子元素的MeasureSpec的创建与父容器的MeasureSpec和子元素自身的LayoutParams有关，此外还和View的margin及padding有关，代码如下:<br><img src="http://dn-arsenan.qbox.me/14728015696076.jpg" alt=""><br>可以以图表的方式更为直观的展示出这个方法的结果<br><img src="http://dn-arsenan.qbox.me/14728016703695.jpg" alt=""></p>
<h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><p>layout过程决定了View的四个顶点和实际的View的宽高，完成以后，可以通过getTop、getBottom、getLeft和getRight来拿到View四个顶点的位置，并可以通过getWidth和getHeight方法来拿到View最终的宽高</p>
<h2 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h2><p>流程如下:<br><img src="http://dn-arsenan.qbox.me/14728028724626.png" alt=""></p>
<h2 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>自定义View大致可分为4类:</p>
<ul>
<li>继承View重写onDraw方法</li>
<li>继承ViewGroup派生特殊的Layout</li>
<li>继承特定的View(比如TextView)</li>
<li>继承特定的ViewGroup(比如LinearLayout)</li>
</ul>
<p><img src="http://dn-arsenan.qbox.me/14728066267414.jpg" alt=""></p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul>
<li>让View支持wrap_content</li>
<li>如果有必要，让View支持padding<br>这是因为直接继承View的控件，如果不在draw方法中处理padding，那么padding属性是无法起作用的。另外，直接继承自ViewGroup的控件需要在onMeasure和onLayout中考虑padding和子元素的margin对其造成的影响，不然将导致padding和子元素的margin失效</li>
<li>尽量不要在View中使用Handler，没必要<br>这是因为View内部本身就提供了post系列方法，完全可以替代Handler的作用</li>
<li>View中如果又线程或者动画，要及时停止，否则会又可能造成内存泄露，可以在onDetachedFromWindow()和onAttachedToWindow()中触发线程或动画的停止和启动</li>
<li>View带有滑动嵌套情形时，需要处理好滑动冲突</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p><img src="http://dn-arsenan.qbox.me/14728041624573.png" alt=""></p>
<ul>
<li><strong>invalidate()</strong><br>请求重绘View树，即draw过程，假如视图大小没有变化就不会调用layout过程，并且只绘制那些调用了invalidate()方法的View</li>
<li><strong>requestLayout()</strong><br>当布局变化的时候，比如方向的变化，尺寸的变化，会调用该方法，在自定义的视图中，如果希望重新测量尺寸大小的时候，应该手动去调用该方法，它会触发measure和layout过程，但不会进行draw</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f" target="_blank" rel="external">公共技术点之 View 绘制流程</a></li>
<li><a href="http://item.jd.com/11760209.html" target="_blank" rel="external">Android开发艺术探究</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;绘制流程概览&quot;&gt;&lt;a href=&quot;#绘制流程概览&quot; class=&quot;headerlink&quot; title=&quot;绘制流程概览&quot;&gt;&lt;/a&gt;绘制流程概览&lt;/h2&gt;&lt;p&gt;整个View树的绘制流程是从ViewRootImpl的performTraversals开始的，依次会调用p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android界面显示分析</title>
    <link href="http://gunner4life.com//blog/2016/09/01/Android%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E5%88%86%E6%9E%90/"/>
    <id>http://gunner4life.com//blog/2016/09/01/Android界面显示分析/</id>
    <published>2016-09-01T10:15:32.000Z</published>
    <updated>2016-09-01T10:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="setContentView"><a href="#setContentView" class="headerlink" title="setContentView"></a>setContentView</h2><p>在Activity中通常我们只需要调用setContentView即可展示我们想要显示的页面，那么setContentView里具体的实现是怎样的呢? 我们来看下它的源码<br><img src="http://dn-arsenan.qbox.me/14726968277647.jpg" alt=""><br>可以看到会去调用Window的setContentView方法，Window是一个抽象类，它的实现类为PhoneWindow，即会调用到PhoneWindow的setContentView方法<br><img src="http://dn-arsenan.qbox.me/14726978743152.jpg" alt=""><br>如果是第一次调用，则调用installDecor方法，否则判断是否设置了FEATURE_CONTENT_TRANSITIONS属性(默认false)，如果没有则移除mContentParent内所有的子View(所以说在我们应用程序里可以多次调用setContentView来显示界面，因为会removeAllViews)，接着会调用LayoutInflater的inflater方法，将资源文件转换为View树，并且添加至mContentParent视图中<br>回过头，继续看第一次调用时会调用的installDecor方法<br><img src="http://dn-arsenan.qbox.me/14726988301196.jpg" alt=""><br>首先会判断mDecor对象是否为空，如果为空则会调用generateDecor创建一个DecorView(DecorView是PhoneWindow的内部类，继承了FrameLayout，是对FrameLayout进行功能的修饰，是所有应用窗口的根View)<br><img src="http://dn-arsenan.qbox.me/14726989748099.jpg" alt=""><br>回到installDecor继续往下看<br><img src="http://dn-arsenan.qbox.me/14726999538555.jpg" alt=""><br>会调用generateLayout方法<br><img src="http://dn-arsenan.qbox.me/14727000942738.jpg" alt=""><br>开始时会根据设置的theme或者feature，对Window进行设置(这也是为什么在Java文件设置Feature时必须在setContentView之前调用的原因，因为Feature的处理是在setContentView里执行的)，接着会运行<br><img src="http://dn-arsenan.qbox.me/14727009766157.jpg" alt=""><br>通过inflate将布局文件转为对应的View，然后添加到decor(PhoneWindow的mDecor)中去<br>最后这些都执行完之后会继续执行PhoneWindow的setContentView中的代码，可以看到最后会调用一个Callback接口的成员函数onContentChanged来通知对应的Activity组件视图内容发生了变化，这个Callback对象是在Activity的attach方法中进行设置的<br><img src="http://dn-arsenan.qbox.me/14727100316941.jpg" alt=""><br>而attach方法的调用则是在ActivityThread的performLaunchActivity中，即Activity启动后调用的(详见<a href="http://gunner4life.com/blog/2016/08/31/Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">Activity启动过程分析</a>)</p>
<h2 id="makeVisible"><a href="#makeVisible" class="headerlink" title="makeVisible"></a>makeVisible</h2><p>上面分析了调用setContentView后流程，可以看到这个方法自身是不显示布局的，那么系统是如何来显示页面的呢？<br>这一点就需要回到ActivityThread里去了，在Activity的performLaunchActivity执行完后会调用handleResumeActivity方法<br><img src="http://dn-arsenan.qbox.me/14727118138044.jpg" alt=""><br>最后会调用到Activity的makeVisible方法<br><img src="http://dn-arsenan.qbox.me/14727122011299.jpg" alt=""><br>makeVisible方法会调用ViewManager的addView方法，DecorView对象为其中的一个参数，然后会调用DecorView的setVisibility将View设置为VISIBLE，这样就能够把setContentView设置的布局显示出来了</p>
<h2 id="Window-WindowManager-ViewManager"><a href="#Window-WindowManager-ViewManager" class="headerlink" title="Window WindowManager ViewManager"></a>Window WindowManager ViewManager</h2><p>上面说了makeVisible方法中会调用ViewManager的addView方法，那么这个方法是干什么用的呢？要理解这个，首先需要知道几个概念: Window WindowManager<br>Window是一个抽象类，它的具体实现是PhoneWindow。Window是一个抽象的概念(Window)，每一个Window都对应着一个View和一个ViewRootImpl, Window和View通过ViewRootImpl来建立联系，因此Window并不是实际存在的，它是以View的形式存在。这点从WindowManager的定义也可以看出，它提供的三个接口方法addView、updateViewLayout以及removeView都是针对View的，这说明View才是Window存在的实体。在实际使用中无法直接访问Window，对Window的访问必须通过WindowManager<br>WindowManager继承自ViewManager，他们都是接口，其中ViewManager代码如下:<br><img src="http://dn-arsenan.qbox.me/14727167185393.jpg" alt=""><br>可以看到它提供了对子View进行添加、删除、更新的方法，也就是说WindowManager通过继承它也得到了这些能力，而它的真正实现类是WindowManagerImpl<br>回到Activity的attach方法<br><img src="http://dn-arsenan.qbox.me/14727170957109.jpg" alt=""><br><img src="http://dn-arsenan.qbox.me/14727171470238.jpg" alt=""><br>可以看到对Activity的PhoneWindow调用了setWindowManager方法，这个方法里会调用WindowManagerImpl的createLocalWindowManager方法<br><img src="http://dn-arsenan.qbox.me/14727172589596.jpg" alt=""><br>总结一下就是Activity及PhoneWindow中的mWindowManager对象指向的就是一个WindowManagerImpl对象，<strong>之前makeVisible方法中使用的也就是这个对象</strong><br>接下来就来看看WindowManagerImpl里的几个方法<br><img src="http://dn-arsenan.qbox.me/14727176730576.jpg" alt=""><br>可以看到，WindowManagerImpl并没有直接实现WindowManager里的接口方法，而是全部交给了WindowManagerGlobal来处理<br>在WindowManagerGlobal有几个列表比较重要<br><img src="http://dn-arsenan.qbox.me/14727186421021.jpg" alt=""><br>其中mViews存储的是所有Window所对应的View，mRoots存储的是所有Window所对应的ViewRootImpl，mParams存储的是所有Window所对应的布局参数，在addView中通过如下方式将Window的一系列对象添加到列表中<br><img src="http://dn-arsenan.qbox.me/14727187853619.jpg" alt=""><br>接着会调用ViewRootImpl的setView方法，在里面会调用requestLayout来进行异步刷新请求<br><img src="http://dn-arsenan.qbox.me/14727190812240.jpg" alt=""><br><img src="http://dn-arsenan.qbox.me/14727193489694.jpg" alt=""><br>scheduleTraversals实际上是View绘制的入口，通过这个后续会执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">doTraversal -&gt; performTraversals -&gt; measure -&gt; layout -&gt; draw</div></pre></td></tr></table></figure>
<p>接着回到setView方法中，当执行完requestLayout，会继续执行<br><img src="http://dn-arsenan.qbox.me/14727202386172.jpg" alt=""><br>这个mWindowSession是个什么东西呢?<br><img src="http://dn-arsenan.qbox.me/14727203945275.jpg" alt=""><br>通过源码得知，这个IWindowSession是一个Binder对象，它的实现类是Session，(ViewRootImpl)通过它来与WindowManagerService进行通信<br>回到addToDisplay方法中<br><img src="http://dn-arsenan.qbox.me/14727245232338.jpg" alt=""><br>这样就把Window的添加请求交给WindowManagerService去处理了</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li><p>Activity层级结构图<br><img src="http://dn-arsenan.qbox.me/2016-03-16_56e8da7959677.jpg" alt="2016-03-16_56e8da7959677"></p>
</li>
<li><p>Android窗口管理框架<br><img src="http://dn-arsenan.qbox.me/2016-03-16_56e8da7d2d3a7.jpg" alt="2016-03-16_56e8da7d2d3a7"></p>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.kancloud.cn/digest/androidframeworks/127786" target="_blank" rel="external">Activity界面显示全解析</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;setContentView&quot;&gt;&lt;a href=&quot;#setContentView&quot; class=&quot;headerlink&quot; title=&quot;setContentView&quot;&gt;&lt;/a&gt;setContentView&lt;/h2&gt;&lt;p&gt;在Activity中通常我们只需要调用set
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android事件分发机制</title>
    <link href="http://gunner4life.com//blog/2016/08/31/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>http://gunner4life.com//blog/2016/08/31/Android事件分发机制/</id>
    <published>2016-08-31T12:42:09.000Z</published>
    <updated>2016-08-31T12:42:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分发流程概述"><a href="#分发流程概述" class="headerlink" title="分发流程概述"></a>分发流程概述</h2><p>所有Touch事件都被封装成MotionEvent对象，包括Touch的位置、时间、历史记录等等。事件最先传递给当前的Activity，由Activity的dispatchTouchEvent来进行事件的分发<br><img src="http://dn-arsenan.qbox.me/14726430496180.jpg" alt=""><br>事件开始交给Activity所附属的Window来进行分发，Window是个抽象类，具体的实现在PhoneWindow当中<br><img src="http://dn-arsenan.qbox.me/14726432484932.jpg" alt=""><br>其中mDecor为DecorView，即根View<br><img src="http://dn-arsenan.qbox.me/14726431452301.jpg" alt=""><br>即事件传递到了ViewGroup的dispatchTouchEvent中，然后继续传递给子元素(默认情况)<br>总的来说，当一个点击事件产生后，它的传递过程遵循如下顺序：Activity -&gt; Window -&gt; View，即事件总是先传递给Activity，Activity再传递给Window，最后Window再传递给顶级的View(DecorView)，顶级View接收到事件后，就会按照事件分发机制去分发事件。如果一个View的onTouchEvent返回false(没有消耗事件)，那么它父容器的onTouchEvent将会被调用，依次类推，如果所有的元素都不去处理这个事件，那么这个事件最终将会传递给Activity处理，即Activity的onTouchEvent方法会被调用</p>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul>
<li>如果ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件(ViewGroup的onInterceptTouchEvent默认返回false，即默认不拦截任何事件)，接着这个ViewGroup的onTouchEvent就会被调用，如果onInterceptTouchEvent返回false，那么就会继续向下调用子元素的dispatchTouchEvent方法</li>
<li>当一个View需要处理事件的时候，如果它没有设置onTouchListener，那么就会直接调用onTouchEvent，如果设置了onTouchListener，那么就要看Listener的onTouch方法返回值，为false，则当前View的onTouchEvent方法会被调用，如果为true，则onTouchEvent将不会被调用。</li>
<li>给View设置onTouchListener，其优先级比onTouchEvent要高，在onTouchEvent方法中，如果设置了onClickListener，那么它的onClick方法会被调用。可以看出，onClickListener的优先级最低</li>
<li>某个View一旦拦截了某个事件，那么这一个事件序列里面后续的Move、Down等事件都会交由它处理，并且它的onTnterceptTouchEvent不会再调用</li>
<li>某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件，那么同一时间序列中的其他事件都不会再交给它来处理，并且事件将重新交给它的父元素处理，即父元素的onTouchEvent会被调用</li>
<li>View的onTouchEvent默认都会消耗事件(返回true)，除非它是不可点击的(clickable和longClickable同时为false)，但是enable属性不会影响onTouchEvent返回值</li>
<li>事件传递过程是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的时间分发，但是ACTION_DOWN事件除外，它不受此影响</li>
</ul>
<ol>
<li><p>View不处理事件流程图<br><img src="http://dn-arsenan.qbox.me/ignorant-view-example.jpg" alt="ignorant-view-example"></p>
</li>
<li><p>View处理事件流程图<br><img src="http://dn-arsenan.qbox.me/interested-view-example.jpg" alt="interested-view-example"></p>
</li>
<li><p>ViewGroup拦截事件处理流程图<br><img src="http://dn-arsenan.qbox.me/14726463384715.jpg" alt=""></p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://a.codekk.com/detail/Android/Trinea/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20View%20%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92" target="_blank" rel="external">公共技术点之View事件传递</a></li>
<li><a href="http://trinea.github.io/download/pdf/android/PRE_andevcon_mastering-the-android-touch-system.pdf" target="_blank" rel="external">Mastering the Android Touch System</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分发流程概述&quot;&gt;&lt;a href=&quot;#分发流程概述&quot; class=&quot;headerlink&quot; title=&quot;分发流程概述&quot;&gt;&lt;/a&gt;分发流程概述&lt;/h2&gt;&lt;p&gt;所有Touch事件都被封装成MotionEvent对象，包括Touch的位置、时间、历史记录等等。事件最先传
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android消息机制</title>
    <link href="http://gunner4life.com//blog/2016/08/31/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>http://gunner4life.com//blog/2016/08/31/Android消息机制/</id>
    <published>2016-08-31T08:22:38.000Z</published>
    <updated>2016-08-31T09:07:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android的消息机制主要是指Handler的运行机制. 而Handler的运行需要底层的MessageQueue和Looper做支撑</p>
<ul>
<li>MessageQueue内部存储了一组消息，以队列的形式对外提供入列和出列的操作，采用的是单链表的数据结构来存储消息队列</li>
<li>Looper会以无限循环的形式去查找MessageQueue中是否有新的消息，如有就处理消息，否则就一直等待着</li>
</ul>
<h2 id="Handler的创建"><a href="#Handler的创建" class="headerlink" title="Handler的创建"></a>Handler的创建</h2><p>首先看一下Handler的构造函数<br><img src="http://dn-arsenan.qbox.me/14726229847414.jpg" alt=""><br>可以看到会通过调用Looper.myLooper()方法来获取一个Looper对象，如果Looper对象为空，则会抛出一个运行时异常，继续看myLooper方法<br><img src="http://dn-arsenan.qbox.me/14726231666612.jpg" alt=""><br>这个方法非常简单，就是从sThreadLocal对象中取出Looper，那么由此而来的一个问题便是在哪里给sThreadLocal设置了Looper，通过阅读代码可知，设置的地方位于prepare方法当中<br><img src="http://dn-arsenan.qbox.me/14726233498932.jpg" alt=""><br>总结一下，就是必须先调用Looper.prepare()方法来创建一个Looper对象，否则无法创建Handler对象<br>But…<br>为什么我们在主线程中不需要通过调用prepare方法也能创建Handler呢？<br>这是由于在程序启动时，系统已经帮我们自动调用了Looper.prepareMainLooper()方法，当App的进程创建好之后，会去执行ActivityThread中的main()方法，main方法的代码如下<br><img src="http://dn-arsenan.qbox.me/14726240426790.jpg" alt=""><br>而prepareMainLooper方法中又会去调用prepare方法<br><img src="http://dn-arsenan.qbox.me/14726241118057.jpg" alt=""><br>因此我们应用程序的主线程种始终存在一个Looper对象，因而不需要再通过调用Looper.prepare来再进行创建，可以直接在主线程中直接创建Handler对象</p>
<h2 id="发送Message"><a href="#发送Message" class="headerlink" title="发送Message"></a>发送Message</h2><p>通常我们先实例化一个Message对象，然后通过Handler的sendMessage方法来发送这条消息，那么这条消息是如何被发送出去的呢？<br>首先看一下sendMessage方法<br><img src="http://dn-arsenan.qbox.me/14726255951577.jpg" alt=""><br>会调用sendMessageDelayed方法，delayMillis为0，表示的是消息不做延时发送<br><img src="http://dn-arsenan.qbox.me/14726256231796.jpg" alt=""><br>然后会继续调用sendMessageAtTime方法，传入发送的时间<br><img src="http://dn-arsenan.qbox.me/14726257474287.jpg" alt=""><br>这里可以看到在继续处理之前会先获取MessageQueue实例，这个就是我们前面提到的消息存储的队列，这个队列是在Handler创建时从Looper中获取的(详见上面Handler构造函数)，而Looper中的mQueue是在Looper创建时new出来的<br>总结起来就是Looper.prepare时会调用Looper的构造函数，创建一个MessageQueue对象，然后Handler在实例化的时候会将当前Looper的MessageQueue赋值给Handler<br>继续上面发送消息的流程，可以看到获取到这个MessageQueue对象之后，会调用enqueueMessage方法<br><img src="http://dn-arsenan.qbox.me/14726264714931.jpg" alt=""><br>首先会设置Message中的target为当前的Handler，然后继续调用MessageQueue的enqueueMessage方法<br><img src="http://dn-arsenan.qbox.me/14726267478155.jpg" alt=""><br>通过代码可以知道这是通过单链表的方式来存储消息，消息的入队其实就是将所有的消息按时间来进行排序，通过以上流程就完成了一个Message的入队操作(通过MessageQueue存储)</p>
<h2 id="Looper获取消息"><a href="#Looper获取消息" class="headerlink" title="Looper获取消息"></a>Looper获取消息</h2><p>前面分析了一个Message从创建到最终如何存储到MessageQueue的过程，接下来我们看看MessageQueue中消息的出队流程。MessageQueue的出队是依靠Looper中的loop方法来实现的<br><img src="http://dn-arsenan.qbox.me/14726277745914.jpg" alt=""><br><img src="http://dn-arsenan.qbox.me/14726291564401.jpg" alt=""></p>
<p>可以看到loop方法是一个死循环，唯一跳出循环的方式是MessageQueue的next方法返回了null。而next方法是一个阻塞操作，当没有消息时，next方法会一直阻塞在那里，这也导致loop方法一直阻塞在那里(新消息来了后会继续处理，处理完后继续阻塞)。只有当Looper的quit方法被调用时，Looper会调用MessageQueue的quit或者quitSafely方法来通知消息队列退出，当消息队列被标为退出状态时，它的next方法就会返回null，此时loop方法才会跳出死循环<br>总结一下就是，loop方法会不断的调用MessageQueue的next方法来获取队列中的消息，没有消息时，也不会退出循环，当有新消息来的时候又能够及时的去处理消息，只有通过调用quit方法才能让Looper退出循环</p>
<h2 id="处理消息"><a href="#处理消息" class="headerlink" title="处理消息"></a>处理消息</h2><p>继续上面的分析可知，loop中取出的消息是通过调用msg.target.dispatchMessage来处理的，这个msg.target就是对应的Handler对象(详见上面Handler的sendMessage方法)，即消息最终是交由Handler的dispatchMessage来处理的，而dispatchMessage是在创建Handler时所使用的Looper中执行的，这样就成功的将代码逻辑切换到指定的线程中去执行了<br><img src="http://dn-arsenan.qbox.me/14726305495162.jpg" alt=""><br>dispatchMessage方法的实现如上，当没有callback时(Handler sendMessage方法就是没有callback)，最终会执行handleMessage方法，这样就收到了之前发送的消息</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>整个消息处理流程示意图如下<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-31%20%E4%B8%8B%E5%8D%885.04.11.png" alt="屏幕快照 2016-08-31 下午5.04.11"></p>
<p>另外除了发送消息之外，还有几种方法能在子线程中进行UI操作:</p>
<ul>
<li>Handler的post方法</li>
<li>View的post方法</li>
<li>Activity的runOnUiThread方法</li>
</ul>
<p>具体的实现跟上面的流程没什么区别，唯一的区别是消息的不是在handleMessage中处理，而是通过callback方式处理(参见上面的dispatchMessage)</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/9991569" target="_blank" rel="external">Android异步消息处理机制完全解析，带你从源码的角度彻底理解</a></li>
<li><a href="https://www.zhihu.com/question/34652589" target="_blank" rel="external">Android中为什么主线程不会因为Looper.loop()里的死循环卡死</a></li>
<li><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="external">Android消息机制1-Handler(Java层)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android的消息机制主要是指Handler的运行机制. 而Handler的运行需要底层的MessageQueue和Looper做支撑&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MessageQueue内部存储了一组消息，以队列的形式对外提供入列和出列的操作，采用的是单链表的数据结构来存
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android系统启动流程</title>
    <link href="http://gunner4life.com//blog/2016/08/31/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://gunner4life.com//blog/2016/08/31/Android系统启动流程/</id>
    <published>2016-08-31T01:53:22.000Z</published>
    <updated>2016-08-31T01:55:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-30%20%E4%B8%8B%E5%8D%883.15.05.png" alt="屏幕快照 2016-08-30 下午3.15.05"></p>
<ul>
<li>Linux Kernel加载完成后，会运行init.rc脚本</li>
<li>init进程执行app_process，创建Zygote进程，然后通过AppRuntime这个对象启动ZygoteInit类</li>
<li>运行ZygoteInit的main方法，首先会通过registerZygoteSocket方法创建一个供AMS使用的server socket</li>
<li>通过调用startSystemServer，会调用Zygote.forkSystemServer来fork出SystemServer进程</li>
<li>SystemServer进程启动后会执行<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-30%20%E4%B8%8B%E5%8D%883.30.48.png" alt="屏幕快照 2016-08-30 下午3.30.48"><br>从而将ActivityManagerService、WindowManagerService、PackageManagerService等系统核心服务启动起来</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-30%20%E4%B8%8B%E5%8D%883.15.05.png&quot; alt=&quot;屏幕快照 2016-08-
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Activity启动过程分析</title>
    <link href="http://gunner4life.com//blog/2016/08/31/Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://gunner4life.com//blog/2016/08/31/Activity启动过程分析/</id>
    <published>2016-08-31T01:51:56.000Z</published>
    <updated>2016-08-31T01:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="APP首次启动"><a href="#APP首次启动" class="headerlink" title="APP首次启动"></a>APP首次启动</h2><p><img src="http://dn-arsenan.qbox.me/start_activity_process.jpg" alt="start_activity_process"></p>
<ol>
<li>Launcher进程通过Binder向SystemServer进程发起startActivity请求</li>
<li>SystemServer收到请求后，向Zygote进程发起创建进程的请求</li>
<li>Zygote进程fork出新的子进程，即App进程，然后执行ActivityThread的main方法</li>
<li>App进程通过Binder向SystemServer进程发起attachApplication请求<br>App首次启动较正常的Activity启动多出了2、3、4三个步骤，其余的完整启动过程请参见下面的「调用流程」</li>
</ol>
<h2 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h2><p><strong>1. 调用Activity的startActivity方法</strong><br><img src="http://dn-arsenan.qbox.me/14725443309497.jpg" alt=""><br>最终会走到startActivityForResult中，当Activity没有父Activity时，会调用Instrumentation的execStartActivity</p>
<hr>
<p><strong>2. 调用Instrumentation的execStartActivity</strong><br><img src="http://dn-arsenan.qbox.me/14725442182212.jpg" alt=""><br>最终调用的是ActivityManagerNative.getDefault().startActivity</p>
<hr>
<p><strong>3. 调用ActivityManagerNative.getDefault()的startActivity</strong><br><img src="http://dn-arsenan.qbox.me/14725447896006.jpg" alt=""><br><img src="http://dn-arsenan.qbox.me/14725447592646.jpg" alt=""><br>由以上可知ActivityManagerNative.getDefault().startActivity实际上调用的是ActivityManagerProxy(ActivityManagerProxy为ActivityManagerNative的内部类)的startActivity方法，具体实现如下:<br><img src="http://dn-arsenan.qbox.me/14725450883257.jpg" alt=""><br>其中mRemote是一个IBinder对象，由ActivityManagerProxy的构造函数中传入，对应的就是asInterface方法中的obj对象，继续追踪可知，这个obj对象指向的是远程的ActivityManagerService，通过调用mRemote.transact(START_ACTIVITY_TRANSACTION)会通过Binder进程间通信机制，发起START_ACTIVITY_TRANSACTION事务，并将Intent等信息序列化后传给远程服务ActivityManagerService</p>
<hr>
<p><strong>4. 执行ActivityManagerService的startActivity方法</strong><br>ActivityManagerService的startActivity会调用ActivityStackSupervisor的startActivityMayWait，后续又会执行一些其它的调用操作，流程如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startActivityMayWait -&gt; startActivityLocked -&gt; startActivityUncheckedLocked -&gt; startSpecificActivityLocked -&gt; realStartActivityLocked</div></pre></td></tr></table></figure></p>
<p>realStartActivityLocked方法最终的执行如下<br><img src="http://dn-arsenan.qbox.me/14725469143399.jpg" alt=""><br>最终会执行ApplicationThreadProxy的scheduleLaunchActivity方法</p>
<hr>
<p><strong>5. 执行ApplicationThreadProxy的scheduleLaunchActivity方法</strong><br><img src="http://dn-arsenan.qbox.me/14725473289431.jpg" alt=""><br>这里又会通过Binder向远程服务发送一个SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION事务，远端的服务收到之后最终会调用ApplicationThread(ActivityThread的内部类)的scheduleLaunchActivity方法</p>
<hr>
<p><strong>6. 执行ApplicationThread的scheduleLaunchActivity方法</strong><br><img src="http://dn-arsenan.qbox.me/14725477248697.jpg" alt=""><br>调用sendMessage方法，Handler收到消息后会调用handleLaunchActivity方法，里面会依次执行handleConfigurationChanged、performLaunchActivity、handleResumeActivity等方法<br>其中performLaunchActivity方法会先通过反射构造Activity实例，然后调用Activity的attach方法，设置Theme、最后会由Instrumentation调用callActivityOnCreate等方法<br><img src="http://dn-arsenan.qbox.me/14725485607501.jpg" alt=""><br><img src="http://dn-arsenan.qbox.me/14725485923974.jpg" alt=""></p>
<hr>
<p><strong>7. 执行Instrumentation的callActivityOnCreate</strong><br><img src="http://dn-arsenan.qbox.me/14725486990498.jpg" alt=""><br>接着会调用Activity的performCreate方法</p>
<hr>
<p><strong>8. Activity的performCreate方法</strong><br><img src="http://dn-arsenan.qbox.me/14725487574177.jpg" alt=""><br>最终会调用Activity的onCreate方法</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://mouxuejie.com/blog/2016-03-12/activity-launch-analysis/" target="_blank" rel="external">［Android四大组件］Activity启动过程源码分析</a></li>
<li><a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="external">startActivity流程分析(一)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;APP首次启动&quot;&gt;&lt;a href=&quot;#APP首次启动&quot; class=&quot;headerlink&quot; title=&quot;APP首次启动&quot;&gt;&lt;/a&gt;APP首次启动&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://dn-arsenan.qbox.me/start_activity
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Studio创建Google MVP模板</title>
    <link href="http://gunner4life.com//blog/2016/08/30/Android-Studio%E5%88%9B%E5%BB%BAGoogle-MVP%E6%A8%A1%E6%9D%BF/"/>
    <id>http://gunner4life.com//blog/2016/08/30/Android-Studio创建Google-MVP模板/</id>
    <published>2016-08-30T02:46:59.000Z</published>
    <updated>2016-08-30T03:01:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android-Studio模板"><a href="#Android-Studio模板" class="headerlink" title="Android Studio模板"></a>Android Studio模板</h2><p>Android Studio模板能帮助用户快速的在Android Studio种创建文件及生成基础的模板代码，例如可以通过File -&gt; New -&gt; Activity -&gt; Basic Activity来新建一个Basic Activity模板，Android Studio把自动帮我们生成一个Activity及Activity对应的布局文件，这个Basic Activity模板就是Android Studio众多的模板之一</p>
<p>Android Studio工程模板的路径位于/Applications/Android Studio.app/Contents/plugins/android/lib/templates</p>
<p>一个典型的Android Studio模板包含以下内容<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%883.56.39.png" alt="屏幕快照 2016-08-29 下午3.56.39"></p>
<ul>
<li><strong>globals.xml.ftl</strong> 定义了一些全局的变量</li>
<li><strong>recipe.xml.ftl</strong> 定义从模板文件生成代码时需要执行的操作，例如可以cope、merge文件</li>
<li><strong>root/</strong> 包含模板文件的文件夹</li>
<li><strong>template.xml</strong> 定义新建模板面板上所显示的内容(类、布局的名称等)、引用的globals文件、执行的recipe文件等</li>
</ul>
<h2 id="Google-MVP"><a href="#Google-MVP" class="headerlink" title="Google MVP"></a>Google MVP</h2><p>Google MVP模式中包含有:</p>
<ul>
<li><strong>Contract</strong> 定义View接口及Presenter接口的契约类</li>
<li><strong>Fragment</strong> 实现Contract中的View接口，用于UI相关的处理</li>
<li><strong>Presenter</strong> 实现Contract种的Presenter接口，用于业务逻辑相关的处理</li>
<li><strong>Activity</strong> 用于生成Fragment Presenter </li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>template.xml</strong><br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%886.37.28.png" alt="屏幕快照 2016-08-29 下午6.37.28"><br>新建模板面板上显示了包括Activity、Activity Layout、Contract、Presenter、Fragment、Fragment Layout的名称，所有的名称都会随着Activity输入进行动态变化，大部分情况只需要定义好Activity的名称即可</p>
<hr>
<p><strong>recipe.xml.ftl</strong><br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%886.41.41.png" alt="屏幕快照 2016-08-29 下午6.41.41"><br>自动将生成的Activity注册到Manifest文件中，同时会生成MVP的各个文件，最后打开Activity文件</p>
<hr>
<p>MVPContract.java.ftl<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%886.42.21.png" alt="屏幕快照 2016-08-29 下午6.42.21"><br>定义View及Presenter接口</p>
<hr>
<p>MVPFragment.java.ftl<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%886.42.58.png" alt="屏幕快照 2016-08-29 下午6.42.58"></p>
<ol>
<li>绑定Presenter，同时在onResume种调用start方法</li>
<li>提供实例化Fragment的方法</li>
<li>绑定对应的布局文件</li>
</ol>
<hr>
<p>MVPPresenter.java.ftl<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%886.43.42.png" alt="屏幕快照 2016-08-29 下午6.43.42"><br>将View与Presenter互相绑定</p>
<hr>
<p>MVPActivity.java.ftl<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%886.44.19.png" alt="屏幕快照 2016-08-29 下午6.44.19"><br>实例化Fragment、Presenter，同时将Fragment(View)作为参数传入Presenter中</p>
<hr>
<p>AndroidManifest.xml.ftl<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%886.44.59.png" alt="屏幕快照 2016-08-29 下午6.44.59"><br>注册新生成的Activity</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%887.22.32.png" alt="屏幕快照 2016-08-29 下午7.22.32"><br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%887.23.35.png" alt="屏幕快照 2016-08-29 下午7.23.35"><br>之后会生成对应的六个文件<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%887.24.45.png" alt="屏幕快照 2016-08-29 下午7.24.45"><br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%887.24.10.png" alt="屏幕快照 2016-08-29 下午7.24.10"><br>打开的DemoActivity显示如下<br><img src="http://dn-arsenan.qbox.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-29%20%E4%B8%8B%E5%8D%887.24.29.png" alt="屏幕快照 2016-08-29 下午7.24.29"><br>同时DemoActivity也已自动注册到AndroidManifest文件种了<br>至此，就生成了一个完成MVP框架需要的所有文件</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>完整代码请参考 <a href="https://github.com/gunner4life/GoogleMVPTemplate" target="_blank" rel="external">Github</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://robusttechhouse.com/tutorial-how-to-create-custom-android-code-templates/" target="_blank" rel="external">Tutorial How To Create Custom Android Code Templates</a></li>
<li><a href="http://www.i-programmer.info/professional-programmer/resources-and-tools/6845-android-adt-template-format-document.html" target="_blank" rel="external">Android ADT Template Format Document</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Android-Studio模板&quot;&gt;&lt;a href=&quot;#Android-Studio模板&quot; class=&quot;headerlink&quot; title=&quot;Android Studio模板&quot;&gt;&lt;/a&gt;Android Studio模板&lt;/h2&gt;&lt;p&gt;Android Studio
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://gunner4life.com//blog/2016/07/21/hello-world/"/>
    <id>http://gunner4life.com//blog/2016/07/21/hello-world/</id>
    <published>2016-07-21T12:21:37.000Z</published>
    <updated>2016-07-21T12:21:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
